
# Code for paper: Robust Self-calibration of Focal Lengths from the Fundamental Matrix

Preprint available at: [arXiv:2311.16304](https://arxiv.org/abs/2311.16304)

## Installation

1. Clone the repo: `git clone https://github.com/kocurvik/robust_self_calibration`
2. `cd robust_self_calibration`
3. Use conda/mamba to install dependencies from env.yaml
4. Install [Matlab python plugin](https://www.mathworks.com/products/matlab/matlab-and-python.html)
5. Install pybind11: `pip install pybind11`
6. Compile the c++ code:

	    cd cxx
	    python setup.py install
	    cd ..

7. Clone and install the following repositories which implement RFC:

	    git clone https://github.com/kocurvik/opencv 
	    ... follow install instructions... 
	    git clone https://github.com/kocurvik/PoseLib 
	    cd PoseLib 
	    git checkout -b onefocal
	     ... follow install instructions ...
	    cd .. 
	    git clone https://github.com/kocurvik/vsac 
	    cd vsac
	    git checkout -b version2	    
	    ... follow install instructions ...

## Performing Evaluation
First you have to prepare the datasets:

    cd /path/to/the/clone/robust_self_calibration/
    export PYTHONPATH=/path/to/the/clone/robust_self_calibration/
    python datasets/prepare_im.py -n 1000 -m loftr1024 /path/to/phototourism/dataset
    python datasets/prepare_im.py -n 1000 -m loftr1024 /path/to/aachen/dataset
    python datasets/prepare_single.py -n 1000 -m loftr1024 /path/to/ETH3D/multiview/dataset

### Alternative: download the matches
You can alternatively download the matches from this address: TBA

Then you can run the evaluation scripts:

    python eval/uncal.py -nw 4 -m loftr1024  phototourism
    python eval/uncal.py -nw 1  -m loftr1024 aachen
    python eval/uncal.py -nw 4 -m loftr1024 eth3d_multiview

You can also run the scripts in the `eval/synth` folder to get the outputs for the synthetic experiments.

The graph comparing RFC runtimes and accuracy can be generated by running:

    python eval/rfd.py -nw 1 -m loftr1024 phototourism

Note that you can change the correspondences to SP+SG by changing setting `-m sg2048`. You hava to install the networks from: `https://github.com/magicleap/SuperGluePretrainedNetwork` and potentially modify the paths in `utils/matching.py`

If you want to use PoseLib for estimating the fundamental matrices you have to comment and uncomment the relevant parts of the eval scripts. The `-nw` parameter is used for multiprocessing. You can set it to 1 to use only a single process.

## Using the Method Outside This Repo
If you want to use the c++ version you can look at how it is used in `methods/ours.py`. Since the c++ version is installed using a `setup.py` script, the package `iterative_focal` should be available in the whole environment.

If you want to use the Matlab version you should check out the `matlab_utils/engine_calls.py`. Note that when you run the engine you have to specify that the engine includes the relevant folder:

    eng = matlab.engine.start_matlab()  
    s = eng.genpath('path/to/robust_self_calibration/matlab_utils')  
    eng.addpath(s, nargout=0)

*Note*: During experiments we always shifted all of the point correspondences so that the priors for the principal points were at (0, 0). It seems that without this the method is significantly less stable. If you already have F then you can transform it using the eq. (1) from [Peter Sturm's paper](https://citeseerx.ist.psu.edu/document?repid=rep1&type=pdf&doi=d561e7c9075d3a88d40b5e84e1302e422b49b56f) and after you obtain estimates for the principal point you add them to the values you used in the transformation matrices.

## Citation

If you find this repository useful please consider citing:

```
@misc{kocur2023robust,
      title={Robust Self-calibration of Focal Lengths from the Fundamental Matrix}, 
      author={Viktor Kocur and Daniel Kyselica and Zuzana Kúkelová},
      year={2023},
      eprint={2311.16304},
      archivePrefix={arXiv},
      primaryClass={cs.CV}
}
```
